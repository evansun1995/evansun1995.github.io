# 前端缓存

**参考文章：**  
* [一文读懂前端缓存](https://juejin.cn/post/6844903747357769742)  
* [前端缓存最佳实践](https://juejin.cn/post/6844903737538920462)

## 存储方式
当浏览器使用缓存时，会按照以下顺序**依次**获取资源缓存：
1. Service Worker：基于`Web Worker`的原生对象，在其基础上增加了缓存能力，使得用户可以主动发起资源缓存。
2. Memory Cache：内存缓存，只对当前 Tab 生效。几乎所有加载的资源都会被缓存到`Memory Cache`中。当分配的内存空间不足时，浏览器会自动清除部分缓存。
3. Disk Cache：硬盘缓存，持久存储。浏览器会根据`Expires`和`Cache-control`字段判断资源是否需要加入缓存，绝大部分的缓存都来自于此。同`Memory Cache`，浏览器会按策略自动清除可能过期的资源。

## 缓存分类

### 强制缓存（强缓存）
强缓存如果命中将直接使用本地缓存，不会发起 HTTP 请求。  
大致过程是：  
1. 首先判断资源是否有缓存，如果没有，直接直接发起请求，并进行缓存。
2. 如果有缓存，根据资源的`Expires`和`Cache-control`判断资源是否过期
3. 如果过期会继续发起请求

### 对比缓存（协商缓存）
对比缓存是当强制缓存没有命中时执行的逻辑，会发起HTTP请求。  
对比缓存主要由两组字段控制：  
#### 1. Last-Modified & If-Modified-Since  
   前者是首次请求缓存时保留的修改时间，后者是第二次发起请求时，浏览器请求头中的字段，用来传递缓存资源的`Last-Modified`给服务端做对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200，并返回数据。  

   但是该方法有如下缺陷：
   * 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
   * 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

#### 2. Etag & If-None-Match
   为了解决上面的缺陷，设计出了`Etag`和`If-None-Match`两个字段。
   `Etag`存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的`Etag`字段。之后的流程和上述类似，首次请求缓存保留资源的`Etag`，第二次请求时将保存的`Etag`的值存放在`If-None-Match`字段中给服务器对比当前`Etag`，如果相等返回 304，否则返回新资源和 200。

## 缓存配置
简述一下前端和后端可以对缓存的操作：
### 前端
前端能处理的空间很小，只有当服务端没有设置缓存头时才会生效。方式是通过`meta`标签设置`http-equiv`和`content`字段配置**该html文件**的缓存策略：
1. 禁止缓存：
   ```html
   <meta http-equiv="Pragma" content="no-cache">
   <meta http-equiv="Cache-Control" content="no-cache">
   <meta http-equiv="Expires" content="0">
   ```
2. 设置有效时间3600s：
   ```html
   <meta http-equiv="Cache-Control" content="max-age=2000" />
   ```

### 后端
大部分缓存的配置都在服务端完成，这里就不展开阐述，随便举个例子：
#### nginx禁止缓存html文件：
```
location ~.*\.(html)$
{
   add_header 'Cache-Control' 'private,no-store,no-cache,must-revalidate,proxy-revalidate';
}
```

## 缓存策略
1. vue 项目：由于我们脚手架中集成了 webpack，打包时默认资源文件名会加上hash，每次打包生成的资源名称都是不同的（publick文件夹中资源除外）。因此比较合理的缓存方式是：
   * HTML：使用协商缓存。
   * CSS&JS&图片：使用强缓存，文件命名带上 hash 值。
  
2. 传统项目：如果没有使用类似 webpack、gulp 的打包工具，如果非必要，**不建议使用随机数给资源去缓存**。一般的策略是：
   * 不常变化的资源：建议给资源手动添加版本号，配置`max-age=31536000`给一个很大的值（一年），当需要更新时手动修改版本号即可。
   * 经常变化的资源：建议设置`Cache-Control: no-cache`，结合协商缓存验证是否更新。