# 前端缓存

参考文章：https://juejin.cn/post/6844903747357769742

## 存储方式
当浏览器使用缓存时，会按照以下顺序**依次**获取资源缓存：
1. Service Worker：基于`Web Worker`的原生对象，在其基础上增加了缓存能力，使得用户可以主动发起资源缓存。
2. Memory Cache：内存缓存，只对当前Tab生效。几乎所有加载的资源都会被缓存到`Memory Cache`中。当分配的内存空间不足时，浏览器会自动清除部分缓存。
3. Disk Cache：硬盘缓存，持久存储。浏览器会根据`Expires`和`Cache-control`字段判断资源是否需要加入缓存，绝大部分的缓存都来自于此。同`Memory Cache`，浏览器会按策略自动清除可能过期的资源。


## 缓存分类

### 强制缓存（强缓存）
强缓存如果命中将直接使用本地缓存，不会发起HTTP请求。  
大致过程是：  
1. 首先判断资源是否有缓存，如果没有，直接直接发起请求，并进行缓存。
2. 如果有缓存，根据资源的`Expires`和`Cache-control`判断资源是否过期
3. 如果过期会继续发起请求

### 对比缓存（协商缓存）
对比缓存是当强制缓存没有命中时执行的逻辑，会发起HTTP请求。  
对比缓存主要由两组字段控制：  
#### 1. Last-Modified & If-Modified-Since  
   前者是首次请求缓存时保留的修改时间，后者是第二次发起请求时，浏览器请求头中的字段，用来传递缓存资源的`Last-Modified`给服务端做对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200，并返回数据。  

   但是该方法有如下缺陷：
   * 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
   * 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

#### 2. Etag & If-None-Match
   为了解决上面的缺陷，设计出了`Etag`和`If-None-Match`两个字段。
   `Etag`存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的`Etag`字段。之后的流程和上述类似，首次请求缓存保留资源的`Etag`，第二次请求时将保存的`Etag`的值存放在`If-None-Match`字段中给服务器对比当前`Etag`，如果相等返回 304，否则返回新资源和 200。

## 缓存策略
待补充...