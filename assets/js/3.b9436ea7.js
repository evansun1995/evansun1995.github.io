(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{337:function(t,n,e){t.exports=e.p+"assets/img/compilation.bed02be7.png"},387:function(t,n,e){t.exports=e.p+"assets/img/tinypng.425e622d.gif"},388:function(t,n,e){t.exports=e.p+"assets/img/cnpm-sync.67ded814.png"},410:function(t,n,e){"use strict";e.r(n);var a=e(54),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"tinyimg-webpack插件开发笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tinyimg-webpack插件开发笔记"}},[t._v("#")]),t._v(" tinyimg webpack插件开发笔记")]),t._v(" "),a("h3",{attrs:{id:"参考文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章：")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6882551009219575815",target:"_blank",rel:"noopener noreferrer"}},[t._v("嗯，手搓一个TinyPng压缩图片的WebpackPlugin也SoEasy啦"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("在前端性能优化方面，可以选择的方案有很多，常见的优化点有："),a("br"),t._v("\n减少http请求、缓存资源、压缩代码、图片压缩、懒加载、style标签放置头部、script标签放置尾部、减少使用DataUrl、减少Dom操作等。")]),t._v(" "),a("p",[t._v("其中，图片压缩是性能提升最为明显的一种，有人说"),a("strong",[t._v("无论怎样对代码做最好的优化也不及对一张图片做一次压缩好")]),t._v("。在实际开发过程中，一张3mb的图片，经过工具压缩后，能至少减少50%以上的大小，而前端的代码无论怎么压缩优化、可能最终在内存大小上，可能也就只能优化几十kb，所以压缩图片是前端开发过程中必不可少的一样过程。")]),t._v(" "),a("p",[t._v("市面上的图片压缩工具、网站有很多，这里不做赘述，目前最好用的（没有之一）的是tinyPNG（/TinyJPG）")]),t._v(" "),a("p",[a("img",{attrs:{src:e(387),alt:"tinypng",title:"tinypng"}})]),t._v(" "),a("h2",{attrs:{id:"使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),a("p",[t._v("官方提供的使用方法有两种：")]),t._v(" "),a("ol",[a("li",[t._v("打开"),a("a",{attrs:{href:"https://tinypng.com",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方网站"),a("OutboundLink")],1),t._v("，手动上传、压缩、下载，每次最多压缩20张，体积不能超过5mb，超出数量需要开通vip.")]),t._v(" "),a("li",[t._v("使用"),a("a",{attrs:{href:"https://tinypng.com/developers/reference/nodejs",target:"_blank",rel:"noopener noreferrer"}},[t._v("Tinify API"),a("OutboundLink")],1),t._v("，可以通过nodejs自动调用，需要注册账号获取api key，与手动上传相同有数量和体积的限制，且每个账号每个月限制最多上传500张。")])]),t._v(" "),a("p",[t._v("对于我们程序员来说，能交给程序去处理的事情，肯定比手动解决的要好，而对于数量上的限制，总结了一下大致有两种解决方法：")]),t._v(" "),a("ol",[a("li",[t._v("通过代码主动调用官网手动上传图片的api进行上传，通过伪造请求ip的方式绕过接口的数量限制")]),t._v(" "),a("li",[t._v("注册多个账号，通过代码自动读取api key，通过tinify api压缩")])]),t._v(" "),a("p",[t._v("本文我们先采取方法一作为切入点，简单了解一下webpack plugin的开发流程（方法二后面会继续整理出来）")]),t._v(" "),a("h2",{attrs:{id:"为什么是plugin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是plugin"}},[t._v("#")]),t._v(" 为什么是Plugin")]),t._v(" "),a("p",[t._v("我们在面试中提到webpack，经常会被问到的问题是，loader和plugin有什么区别，简单总结一下：")]),t._v(" "),a("h3",{attrs:{id:"loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loader"}},[t._v("#")]),t._v(" loader：")]),t._v(" "),a("p",[t._v("对于loader，官方的解释是")]),t._v(" "),a("blockquote",[a("p",[t._v("webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 "),a("a",{attrs:{href:"https://webpack.docschina.org/concepts/modules",target:"_blank",rel:"noopener noreferrer"}},[t._v("模块"),a("OutboundLink")],1),t._v("，以供应用程序使用，以及被添加到依赖图中。")])]),t._v(" "),a("p",[t._v("因此，loader是专门用来处理文件的，本质是一个函数。loader具有单一职责原则，一个loader只处理一件事（一种类型文件）。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.webpackjs.com/contribute/writing-a-loader/",target:"_blank",rel:"noopener noreferrer"}},[t._v("loader开发官方教程"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"plugin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#plugin"}},[t._v("#")]),t._v(" plugin")]),t._v(" "),a("p",[t._v("plugin官方的介绍是：")]),t._v(" "),a("blockquote",[a("p",[t._v("loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。")])]),t._v(" "),a("p",[t._v("plugin本质是一个类，是对于loader的补充，功能十分强大， 在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。webpack本身内置了很多好用的plugin。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.webpackjs.com/contribute/writing-a-plugin/",target:"_blank",rel:"noopener noreferrer"}},[t._v("plugin开发官方教程"),a("OutboundLink")],1)]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("综上所述，我们的需求使用plugin更为合适。")]),t._v(" "),a("h2",{attrs:{id:"plugin执行时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#plugin执行时机"}},[t._v("#")]),t._v(" plugin执行时机")]),t._v(" "),a("p",[t._v("本次开发的插件是对项目中的所有图片进行压缩，所以选在的 webpack 钩子应该能获取到所有输出前的图片。从"),a("a",{attrs:{href:"https://www.webpackjs.com/api/compiler-hooks/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Webpack Compiler Hooks API文档"),a("OutboundLink")],1),t._v("中可发现，emit 是在生成资源到 output 目录之前执行的钩子，emit在生成资源到输出目录前执行，此刻可获取所有图片文件的数据和输出路径。")]),t._v(" "),a("h2",{attrs:{id:"解决数量限制问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决数量限制问题"}},[t._v("#")]),t._v(" 解决数量限制问题")]),t._v(" "),a("blockquote",[a("p",[t._v("由于大多数Web架构很少会将应用服务器直接对外提供服务，一般都会设置一层Nginx作为代理和负载均衡，有的甚至可能有多层代理。鉴于大多数Web架构都是使用Nginx作为反向代理，用户请求不是直接请求应用服务器的，而是通过Nginx设置的统一接入层将用户请求转发到服务器的，所以可通过设置HTTP请求头字段X-Forwarded-For来伪造IP。"),a("br"),t._v("\nX-Forwarded-For指用来识别通过代理或负载均衡的方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。当然，这个IP也不是一成不变的，每次请求都需随机更换IP，骗过应用服务器。若应用服务器增加了伪造IP识别，那可能就无法继续使用随机IP了。")])]),t._v(" "),a("p",[t._v("补充：因为Nginx转发之后，接口服务器无法直接获取请求客户端的ip地址（获取到发起请求的ip是Nginx服务器的），因此需要Nginx设置"),a("code",[t._v("X-Forwarded-For")]),t._v("请求头，里面携带了实际请求客户端的ip地址（其实还有个"),a("code",[t._v("X-Real-Ip")]),t._v("字段，本文中tinyPng的服务器应该是没有使用该字段）")]),t._v(" "),a("h2",{attrs:{id:"插件工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件工作流程"}},[t._v("#")]),t._v(" 插件工作流程")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("选择一个合适的钩子注册事件")])]),t._v(" "),a("li",[a("p",[t._v("在回调函数中，获取所有图片文件，回调函数compiler参数部分截图如下：\n"),a("img",{attrs:{src:e(337),alt:"compilation",title:"compilation"}})])]),t._v(" "),a("li",[a("p",[a("code",[t._v("compilation")]),t._v("参数部分截图")])]),t._v(" "),a("li",[a("p",[t._v("循环图片文件，伪造随机ip发起上传请求")])]),t._v(" "),a("li",[a("p",[t._v("下载压缩后的图片")])]),t._v(" "),a("li",[a("p",[t._v("获取图片压缩数据用于输出日志")])]),t._v(" "),a("li",[a("p",[t._v("保存压缩后的图片到"),a("code",[t._v("assets")]),t._v("对象，替换原图片")])]),t._v(" "),a("li",[a("p",[t._v("输出日志")])])]),t._v(" "),a("h2",{attrs:{id:"目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[t._v("#")]),t._v(" 目录结构")]),t._v(" "),a("ul",[a("li",[t._v("src\n"),a("ul",[a("li",[t._v("index.js -- 入口文件")]),t._v(" "),a("li",[t._v("schema.json -- 参数校验")])])]),t._v(" "),a("li",[t._v("study -- 参考及学习文件")]),t._v(" "),a("li",[t._v("test -- 测试用例")]),t._v(" "),a("li",[t._v("util\n"),a("ul",[a("li",[t._v("constant.js -- 常量集合")]),t._v(" "),a("li",[t._v("index.js -- 处理函数集合")])])]),t._v(" "),a("li",[t._v(".gitignore")]),t._v(" "),a("li",[t._v(".npmgnore")]),t._v(" "),a("li",[t._v("package.json")]),t._v(" "),a("li",[t._v("readme.md")])]),t._v(" "),a("h2",{attrs:{id:"开发流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发流程"}},[t._v("#")]),t._v(" 开发流程")]),t._v(" "),a("ol",[a("li",[t._v("npm init 初始化项目，创建package.json文件，"),a("code",[t._v("entry point")]),t._v("设置成"),a("code",[t._v("src/index.js")])]),t._v(" "),a("li",[t._v("创建目录结构，安装依赖（一定记得区分"),a("code",[t._v("dependencies")]),t._v("和"),a("code",[t._v("devDependencies")]),t._v("，npm发布中会补充）")]),t._v(" "),a("li",[t._v("编写代码")]),t._v(" "),a("li",[t._v("发布npm")])]),t._v(" "),a("h2",{attrs:{id:"后续升级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后续升级"}},[t._v("#")]),t._v(" 后续升级")]),t._v(" "),a("p",[t._v("经过上述流程后，一个基础的 TinyImg 插件已经初步完成了，但如果直接应用到项目中，还是有一些问题。在实际开发中，每次打包时对所有图片进行上传、压缩然后下载，如果项目中的图片很多，这是十分耗时且重复的一步操作，因此我们需要对已压缩的图片进行缓存。\n大致的处理流程是：")]),t._v(" "),a("ol",[a("li",[t._v("在调用接口压缩图片后，在根目录下的 TINY_IMG_CACHE 目录中，将文件以图片的文件流生成32位哈希值拼上文件后缀作为文件名保存。")]),t._v(" "),a("li",[t._v("在处理图片文件时，用上述处理方式生成的文件名在 TINY_IMG_CACHE 目录中寻找是否存在，如果存在直接使用缓存文件，否则走上述1中的逻辑。")])]),t._v(" "),a("p",[a("strong",[t._v("注意")]),t._v("：处理缓存文件时，因为统一放在一个文件夹中，如果图片内容完全相同，处理出来的32位哈希值也会是相同的，因此处理时后处理的文件会走缓存逻辑，个人认为这样没问题，可以合理使用缓存。如果想避免这种情况，可以给文件名拼接上一些文件信息，如文件夹路径。另外因为我们使用MD5加密的方式处理出来的32位哈希值，理论上是有可能重复的，比较严谨的方法也是可以拼上一些文件信息。")]),t._v(" "),a("p",[a("strong",[t._v("补充：为什么不直接替换assets中的源文件？")]),a("br"),t._v("\n开始时有考虑过这个问题，最终考虑到我们的项目是使用jenkins发版，打包是在jenkins服务器中，打包后改变的只是服务器中的文件，每次发版时文件又会被重置，相当于没有缓存。而如果我们在本地压缩完图片后再上传，那本质上我们应该开发的是一个nodejs脚本，脱离了开发webpack插件的初衷，毕竟webpack是一个打包工具，插件是在打包时才去执行的。")]),t._v(" "),a("h2",{attrs:{id:"发布npm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发布npm"}},[t._v("#")]),t._v(" 发布npm")]),t._v(" "),a("p",[t._v("整体代码开发完成后，为了方便项目的使用以及版本的管理，我们需要将插件发布到npm上。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("确保 node 和 npm 版本\n我们要确保node版本在 14.18.0 及以上，且安装最新版本 npm ，否则 npm 在登录时会报"),a("code",[t._v("426 Upgrade Required")]),t._v("。\n原因：2021年10月4日后，npm 网站和 npm registry 必须使用 TLS 安全套接层 1.2 版本，所以需要升级对应版本。\n这里推荐大家使用 nvm 管理 node 版本，切换 node 版本后，执行"),a("code",[t._v("cnpm install -g npm@latest")]),t._v("安装最新版本 npm，记得"),a("strong",[t._v("不要使用")]),t._v("npm 去升级自身，会报错。")]),t._v(" "),a("p",[t._v("参考："),a("a",{attrs:{href:"https://blog.csdn.net/weixin_41697143/article/details/120650358",target:"_blank",rel:"noopener noreferrer"}},[t._v("关于npm版本问题"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[t._v("package.json配置\n确保填写好正确的"),a("code",[t._v("name")]),t._v("（npm包名）、"),a("code",[t._v("version")]),t._v("（版本号，尽量小一些）、"),a("code",[t._v("main")]),t._v("（入口文件）、"),a("code",[t._v("repository")]),t._v("（git管理地址，非必填），"),a("code",[t._v("private")]),t._v("需要设置为"),a("code",[t._v("false")]),t._v("（表明是公开项目），此外还要确保依赖安装时位置是否正确。")]),t._v(" "),a("p",[a("strong",[t._v("重点：")]),t._v("\n我们在开发过程中使用的依赖，如果是插件运行过程中使用的，必须安装到"),a("code",[t._v("dependencies")]),t._v("中，否则发布后，项目引入后，插件的相关依赖不会被 npm 安装（执行时会报依赖找不到）。\n如果是如本地测试的代码用到的依赖，则最好安装在"),a("code",[t._v("devDependencies")]),t._v("中，这样在项目使用时这些用不到的依赖不会被安装。")])]),t._v(" "),a("li",[a("p",[t._v("发布:"),a("br"),t._v(" "),a("code",[t._v("npm login")]),t._v(" （登录）"),a("br"),t._v(" "),a("code",[t._v("npm publish")]),t._v(" （发布）")]),t._v(" "),a("p",[t._v("补充：\n如果使用cnpm安装依赖，当"),a("code",[t._v("npm publish")]),t._v("发布依赖后，如果 cnpm 没有同步，常见于多次发版后，解决方法：\n点击进入"),a("a",{attrs:{href:"https://developer.aliyun.com/mirror/NPM?from=tnpm",target:"_blank",rel:"noopener noreferrer"}},[t._v("cnpm官网"),a("OutboundLink")],1),t._v("\n搜索包名，点击下图所示 SYNC 按钮，手动进行同步。\n"),a("img",{attrs:{src:e(388),alt:"cnpmsync",title:"cnpm sync"}})])]),t._v(" "),a("li",[a("p",[t._v("在项目中引入:")])])]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("// 安装依赖\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" tinyimg-webpack-plugin-no-key -D\n")])])]),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// vue.config.js 配置")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" TinyimgWebpackPlugin "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'tinyimg-webpack-plugin-no-key'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n\nmodule"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ....")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("configureWebpack")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("config")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ....")]),t._v("\n    config"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("plugins"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TinyimgWebpackPlugin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// enabled:Boolean，默认true,")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// logged:Boolean，默认true")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("补充")]),t._v("：如果使用了多个插件，关于 webpack 插件的执行顺序，首先肯定是不同钩子的执行顺序是固定的，可以看文档，而相同钩子内的执行顺序是钩子本身决定的。比如"),a("code",[t._v("emit")]),t._v("钩子是一个"),a("code",[t._v("AsyncSeriesHook")]),t._v("（异步串行钩子），会根据 plugin 插入的顺序从上向下执行，因此如果你用了比如"),a("code",[t._v("compression-webpack-plugin")]),t._v("，我们需要将该插件放最后，当图片压缩完成后，再处理 gzip 之类的逻辑。")]),t._v(" "),a("p",[t._v("项目源码："),a("a",{attrs:{href:"https://gitee.com/evan-sun/tinyimg-webpack-plugin",target:"_blank",rel:"noopener noreferrer"}},[t._v("EvanSun/tinyimg-webpack-plugin"),a("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=s.exports}}]);