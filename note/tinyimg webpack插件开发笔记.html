<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>tinyimg webpack插件开发笔记 | Evan&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="随手记录日常开发、学习中值得分享的内容。">
    
    <link rel="preload" href="/assets/css/0.styles.f559a7f0.css" as="style"><link rel="preload" href="/assets/js/app.a7708c6f.js" as="script"><link rel="preload" href="/assets/js/2.bfc0227a.js" as="script"><link rel="preload" href="/assets/js/3.b9436ea7.js" as="script"><link rel="prefetch" href="/assets/js/10.d8809b0e.js"><link rel="prefetch" href="/assets/js/11.5992ea45.js"><link rel="prefetch" href="/assets/js/12.b5f08efe.js"><link rel="prefetch" href="/assets/js/13.a6d0a4d0.js"><link rel="prefetch" href="/assets/js/14.7a983533.js"><link rel="prefetch" href="/assets/js/15.f0a68512.js"><link rel="prefetch" href="/assets/js/16.5ae1bdbe.js"><link rel="prefetch" href="/assets/js/17.89054bbc.js"><link rel="prefetch" href="/assets/js/18.a2ef8e9f.js"><link rel="prefetch" href="/assets/js/19.f541730e.js"><link rel="prefetch" href="/assets/js/20.8a833b56.js"><link rel="prefetch" href="/assets/js/21.dc2762e1.js"><link rel="prefetch" href="/assets/js/22.50407e54.js"><link rel="prefetch" href="/assets/js/4.0dd4077a.js"><link rel="prefetch" href="/assets/js/5.c715243f.js"><link rel="prefetch" href="/assets/js/6.c8fbec62.js"><link rel="prefetch" href="/assets/js/7.6bb87242.js"><link rel="prefetch" href="/assets/js/8.af310382.js"><link rel="prefetch" href="/assets/js/9.ac11612e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f559a7f0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Evan's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/team/" class="nav-link">
  团队
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/team/" class="nav-link">
  团队
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/note/" class="sidebar-heading clickable router-link-active open"><span>笔记</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/webpack学习笔记.html" class="sidebar-link">webpack 学习笔记</a></li><li><a href="/note/tinyimg webpack插件开发笔记.html" class="active sidebar-link">tinyimg webpack插件开发笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#使用" class="sidebar-link">使用</a></li><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#为什么是plugin" class="sidebar-link">为什么是Plugin</a></li><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#plugin执行时机" class="sidebar-link">plugin执行时机</a></li><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#解决数量限制问题" class="sidebar-link">解决数量限制问题</a></li><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#插件工作流程" class="sidebar-link">插件工作流程</a></li><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#目录结构" class="sidebar-link">目录结构</a></li><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#开发流程" class="sidebar-link">开发流程</a></li><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#后续升级" class="sidebar-link">后续升级</a></li><li class="sidebar-sub-header"><a href="/note/tinyimg webpack插件开发笔记.html#发布npm" class="sidebar-link">发布npm</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="tinyimg-webpack插件开发笔记"><a href="#tinyimg-webpack插件开发笔记" class="header-anchor">#</a> tinyimg webpack插件开发笔记</h1> <h3 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章：</h3> <p><a href="https://juejin.cn/post/6882551009219575815" target="_blank" rel="noopener noreferrer">嗯，手搓一个TinyPng压缩图片的WebpackPlugin也SoEasy啦<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>在前端性能优化方面，可以选择的方案有很多，常见的优化点有：<br>
减少http请求、缓存资源、压缩代码、图片压缩、懒加载、style标签放置头部、script标签放置尾部、减少使用DataUrl、减少Dom操作等。</p> <p>其中，图片压缩是性能提升最为明显的一种，有人说<strong>无论怎样对代码做最好的优化也不及对一张图片做一次压缩好</strong>。在实际开发过程中，一张3mb的图片，经过工具压缩后，能至少减少50%以上的大小，而前端的代码无论怎么压缩优化、可能最终在内存大小上，可能也就只能优化几十kb，所以压缩图片是前端开发过程中必不可少的一样过程。</p> <p>市面上的图片压缩工具、网站有很多，这里不做赘述，目前最好用的（没有之一）的是tinyPNG（/TinyJPG）</p> <p><img src="/assets/img/tinypng.425e622d.gif" alt="tinypng" title="tinypng"></p> <h2 id="使用"><a href="#使用" class="header-anchor">#</a> 使用</h2> <p>官方提供的使用方法有两种：</p> <ol><li>打开<a href="https://tinypng.com" target="_blank" rel="noopener noreferrer">官方网站<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，手动上传、压缩、下载，每次最多压缩20张，体积不能超过5mb，超出数量需要开通vip.</li> <li>使用<a href="https://tinypng.com/developers/reference/nodejs" target="_blank" rel="noopener noreferrer">Tinify API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，可以通过nodejs自动调用，需要注册账号获取api key，与手动上传相同有数量和体积的限制，且每个账号每个月限制最多上传500张。</li></ol> <p>对于我们程序员来说，能交给程序去处理的事情，肯定比手动解决的要好，而对于数量上的限制，总结了一下大致有两种解决方法：</p> <ol><li>通过代码主动调用官网手动上传图片的api进行上传，通过伪造请求ip的方式绕过接口的数量限制</li> <li>注册多个账号，通过代码自动读取api key，通过tinify api压缩</li></ol> <p>本文我们先采取方法一作为切入点，简单了解一下webpack plugin的开发流程（方法二后面会继续整理出来）</p> <h2 id="为什么是plugin"><a href="#为什么是plugin" class="header-anchor">#</a> 为什么是Plugin</h2> <p>我们在面试中提到webpack，经常会被问到的问题是，loader和plugin有什么区别，简单总结一下：</p> <h3 id="loader"><a href="#loader" class="header-anchor">#</a> loader：</h3> <p>对于loader，官方的解释是</p> <blockquote><p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 <a href="https://webpack.docschina.org/concepts/modules" target="_blank" rel="noopener noreferrer">模块<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，以供应用程序使用，以及被添加到依赖图中。</p></blockquote> <p>因此，loader是专门用来处理文件的，本质是一个函数。loader具有单一职责原则，一个loader只处理一件事（一种类型文件）。</p> <p><a href="https://www.webpackjs.com/contribute/writing-a-loader/" target="_blank" rel="noopener noreferrer">loader开发官方教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="plugin"><a href="#plugin" class="header-anchor">#</a> plugin</h3> <p>plugin官方的介绍是：</p> <blockquote><p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p></blockquote> <p>plugin本质是一个类，是对于loader的补充，功能十分强大， 在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。webpack本身内置了很多好用的plugin。</p> <p><a href="https://www.webpackjs.com/contribute/writing-a-plugin/" target="_blank" rel="noopener noreferrer">plugin开发官方教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <p>综上所述，我们的需求使用plugin更为合适。</p> <h2 id="plugin执行时机"><a href="#plugin执行时机" class="header-anchor">#</a> plugin执行时机</h2> <p>本次开发的插件是对项目中的所有图片进行压缩，所以选在的 webpack 钩子应该能获取到所有输出前的图片。从<a href="https://www.webpackjs.com/api/compiler-hooks/" target="_blank" rel="noopener noreferrer">Webpack Compiler Hooks API文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中可发现，emit 是在生成资源到 output 目录之前执行的钩子，emit在生成资源到输出目录前执行，此刻可获取所有图片文件的数据和输出路径。</p> <h2 id="解决数量限制问题"><a href="#解决数量限制问题" class="header-anchor">#</a> 解决数量限制问题</h2> <blockquote><p>由于大多数Web架构很少会将应用服务器直接对外提供服务，一般都会设置一层Nginx作为代理和负载均衡，有的甚至可能有多层代理。鉴于大多数Web架构都是使用Nginx作为反向代理，用户请求不是直接请求应用服务器的，而是通过Nginx设置的统一接入层将用户请求转发到服务器的，所以可通过设置HTTP请求头字段X-Forwarded-For来伪造IP。<br>
X-Forwarded-For指用来识别通过代理或负载均衡的方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。当然，这个IP也不是一成不变的，每次请求都需随机更换IP，骗过应用服务器。若应用服务器增加了伪造IP识别，那可能就无法继续使用随机IP了。</p></blockquote> <p>补充：因为Nginx转发之后，接口服务器无法直接获取请求客户端的ip地址（获取到发起请求的ip是Nginx服务器的），因此需要Nginx设置<code>X-Forwarded-For</code>请求头，里面携带了实际请求客户端的ip地址（其实还有个<code>X-Real-Ip</code>字段，本文中tinyPng的服务器应该是没有使用该字段）</p> <h2 id="插件工作流程"><a href="#插件工作流程" class="header-anchor">#</a> 插件工作流程</h2> <ol><li><p>选择一个合适的钩子注册事件</p></li> <li><p>在回调函数中，获取所有图片文件，回调函数compiler参数部分截图如下：
<img src="/assets/img/compilation.bed02be7.png" alt="compilation" title="compilation"></p></li> <li><p><code>compilation</code>参数部分截图</p></li> <li><p>循环图片文件，伪造随机ip发起上传请求</p></li> <li><p>下载压缩后的图片</p></li> <li><p>获取图片压缩数据用于输出日志</p></li> <li><p>保存压缩后的图片到<code>assets</code>对象，替换原图片</p></li> <li><p>输出日志</p></li></ol> <h2 id="目录结构"><a href="#目录结构" class="header-anchor">#</a> 目录结构</h2> <ul><li>src
<ul><li>index.js -- 入口文件</li> <li>schema.json -- 参数校验</li></ul></li> <li>study -- 参考及学习文件</li> <li>test -- 测试用例</li> <li>util
<ul><li>constant.js -- 常量集合</li> <li>index.js -- 处理函数集合</li></ul></li> <li>.gitignore</li> <li>.npmgnore</li> <li>package.json</li> <li>readme.md</li></ul> <h2 id="开发流程"><a href="#开发流程" class="header-anchor">#</a> 开发流程</h2> <ol><li>npm init 初始化项目，创建package.json文件，<code>entry point</code>设置成<code>src/index.js</code></li> <li>创建目录结构，安装依赖（一定记得区分<code>dependencies</code>和<code>devDependencies</code>，npm发布中会补充）</li> <li>编写代码</li> <li>发布npm</li></ol> <h2 id="后续升级"><a href="#后续升级" class="header-anchor">#</a> 后续升级</h2> <p>经过上述流程后，一个基础的 TinyImg 插件已经初步完成了，但如果直接应用到项目中，还是有一些问题。在实际开发中，每次打包时对所有图片进行上传、压缩然后下载，如果项目中的图片很多，这是十分耗时且重复的一步操作，因此我们需要对已压缩的图片进行缓存。
大致的处理流程是：</p> <ol><li>在调用接口压缩图片后，在根目录下的 TINY_IMG_CACHE 目录中，将文件以图片的文件流生成32位哈希值拼上文件后缀作为文件名保存。</li> <li>在处理图片文件时，用上述处理方式生成的文件名在 TINY_IMG_CACHE 目录中寻找是否存在，如果存在直接使用缓存文件，否则走上述1中的逻辑。</li></ol> <p><strong>注意</strong>：处理缓存文件时，因为统一放在一个文件夹中，如果图片内容完全相同，处理出来的32位哈希值也会是相同的，因此处理时后处理的文件会走缓存逻辑，个人认为这样没问题，可以合理使用缓存。如果想避免这种情况，可以给文件名拼接上一些文件信息，如文件夹路径。另外因为我们使用MD5加密的方式处理出来的32位哈希值，理论上是有可能重复的，比较严谨的方法也是可以拼上一些文件信息。</p> <p><strong>补充：为什么不直接替换assets中的源文件？</strong><br>
开始时有考虑过这个问题，最终考虑到我们的项目是使用jenkins发版，打包是在jenkins服务器中，打包后改变的只是服务器中的文件，每次发版时文件又会被重置，相当于没有缓存。而如果我们在本地压缩完图片后再上传，那本质上我们应该开发的是一个nodejs脚本，脱离了开发webpack插件的初衷，毕竟webpack是一个打包工具，插件是在打包时才去执行的。</p> <h2 id="发布npm"><a href="#发布npm" class="header-anchor">#</a> 发布npm</h2> <p>整体代码开发完成后，为了方便项目的使用以及版本的管理，我们需要将插件发布到npm上。</p> <ol><li><p>确保 node 和 npm 版本
我们要确保node版本在 14.18.0 及以上，且安装最新版本 npm ，否则 npm 在登录时会报<code>426 Upgrade Required</code>。
原因：2021年10月4日后，npm 网站和 npm registry 必须使用 TLS 安全套接层 1.2 版本，所以需要升级对应版本。
这里推荐大家使用 nvm 管理 node 版本，切换 node 版本后，执行<code>cnpm install -g npm@latest</code>安装最新版本 npm，记得<strong>不要使用</strong>npm 去升级自身，会报错。</p> <p>参考：<a href="https://blog.csdn.net/weixin_41697143/article/details/120650358" target="_blank" rel="noopener noreferrer">关于npm版本问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>package.json配置
确保填写好正确的<code>name</code>（npm包名）、<code>version</code>（版本号，尽量小一些）、<code>main</code>（入口文件）、<code>repository</code>（git管理地址，非必填），<code>private</code>需要设置为<code>false</code>（表明是公开项目），此外还要确保依赖安装时位置是否正确。</p> <p><strong>重点：</strong>
我们在开发过程中使用的依赖，如果是插件运行过程中使用的，必须安装到<code>dependencies</code>中，否则发布后，项目引入后，插件的相关依赖不会被 npm 安装（执行时会报依赖找不到）。
如果是如本地测试的代码用到的依赖，则最好安装在<code>devDependencies</code>中，这样在项目使用时这些用不到的依赖不会被安装。</p></li> <li><p>发布:<br> <code>npm login</code> （登录）<br> <code>npm publish</code> （发布）</p> <p>补充：
如果使用cnpm安装依赖，当<code>npm publish</code>发布依赖后，如果 cnpm 没有同步，常见于多次发版后，解决方法：
点击进入<a href="https://developer.aliyun.com/mirror/NPM?from=tnpm" target="_blank" rel="noopener noreferrer">cnpm官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
搜索包名，点击下图所示 SYNC 按钮，手动进行同步。
<img src="/assets/img/cnpm-sync.67ded814.png" alt="cnpmsync" title="cnpm sync"></p></li> <li><p>在项目中引入:</p></li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code>// 安装依赖
<span class="token function">npm</span> <span class="token function">install</span> tinyimg-webpack-plugin-no-key -D
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vue.config.js 配置</span>
<span class="token keyword">const</span> TinyimgWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'tinyimg-webpack-plugin-no-key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ....</span>
  <span class="token function-variable function">configureWebpack</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// ....</span>
    config<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TinyimgWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// enabled:Boolean，默认true,</span>
     <span class="token comment">// logged:Boolean，默认true</span>
    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>补充</strong>：如果使用了多个插件，关于 webpack 插件的执行顺序，首先肯定是不同钩子的执行顺序是固定的，可以看文档，而相同钩子内的执行顺序是钩子本身决定的。比如<code>emit</code>钩子是一个<code>AsyncSeriesHook</code>（异步串行钩子），会根据 plugin 插入的顺序从上向下执行，因此如果你用了比如<code>compression-webpack-plugin</code>，我们需要将该插件放最后，当图片压缩完成后，再处理 gzip 之类的逻辑。</p> <p>项目源码：<a href="https://gitee.com/evan-sun/tinyimg-webpack-plugin" target="_blank" rel="noopener noreferrer">EvanSun/tinyimg-webpack-plugin<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/webpack学习笔记.html" class="prev">
        webpack 学习笔记
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a7708c6f.js" defer></script><script src="/assets/js/2.bfc0227a.js" defer></script><script src="/assets/js/3.b9436ea7.js" defer></script>
  </body>
</html>
